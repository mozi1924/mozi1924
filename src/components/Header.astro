---
import { Menu, X } from "lucide-react";
import { NAV_LINKS } from "../menu";

interface Props {
  enableReadingProgress?: boolean;
}

const { enableReadingProgress = false } = Astro.props;

const { pathname } = Astro.url;
const normalizePath = (path: string) => {
  const p = path.replace(/\/$/, "") || "/";
  return p;
};
const currentPath = normalizePath(pathname);
---

<header
  class="fixed top-0 w-full z-50 bg-[#111]/80 backdrop-blur-md border-b border-white/10 transition-all duration-300"
>
  <div
    class="max-w-7xl mx-auto px-6 h-16 flex items-center justify-between relative z-50 bg-[#1110]"
  >
    <a href="/" class="flex items-center gap-2 group">
      <div class="relative w-8 h-8 flex items-center justify-center">
        <img
          src="/favicon.svg"
          alt="Mozi Logo"
          class="w-8 h-8 group-hover:scale-110 transition-transform duration-300"
        />
      </div>
      <span class="font-bold text-lg tracking-tight">Mozi's website</span>
    </a>

    <nav class="hidden md:flex items-center gap-8">
      {
        NAV_LINKS.map((link) => {
          const isActive =
            link.href === "/"
              ? currentPath === "/"
              : currentPath.startsWith(link.href);
          return (
            <a
              href={link.href}
              class={`text-sm font-medium transition-colors ${
                isActive ? "text-[#3F89FC]" : "text-gray-300 hover:text-white"
              }`}
            >
              {link.name}
            </a>
          );
        })
      }
    </nav>

    <button
      id="mobile-menu-btn"
      class="md:hidden text-white p-2 focus:outline-none relative w-10 h-10 flex items-center justify-center"
      aria-label="Toggle menu"
    >
      <div class="relative w-6 h-6">
        <Menu
          className="w-6 h-6 absolute inset-0 transition-all duration-300 opacity-100 rotate-0 scale-100"
          id="menu-icon-open"
        />
        <X
          className="w-6 h-6 absolute inset-0 transition-all duration-300 opacity-0 -rotate-90 scale-50"
          id="menu-icon-close"
        />
      </div>
    </button>
  </div>

  <!-- Mobile Menu -->
  <div
    id="mobile-menu"
    class="md:hidden fixed top-16 left-0 w-full h-[calc(100vh-4rem)] bg-[#111] transition-all duration-500 ease-in-out transform translate-y-[-100%] opacity-0 pointer-events-none z-40 border-b border-white/10"
  >
    <nav
      class="h-full flex flex-col items-center justify-center overflow-y-auto"
    >
      <div class="flex flex-col items-center space-y-8 p-8 w-full max-w-md">
        {
          NAV_LINKS.map((link) => {
            const isActive =
              link.href === "/"
                ? currentPath === "/"
                : currentPath.startsWith(link.href);
            return (
              <a
                href={link.href}
                class={`mobile-link text-2xl font-medium transition-colors ${
                  isActive ? "text-[#3F89FC]" : "text-gray-300 hover:text-white"
                }`}
              >
                {link.name}
              </a>
            );
          })
        }
      </div>
    </nav>
  </div>

  <!-- Reading Progress Bar -->
  {
    enableReadingProgress && (
      <div
        id="reading-progress-container"
        class="absolute bottom-0 left-0 w-full h-1 bg-transparent z-50 pointer-events-none"
      >
        <div
          id="reading-progress-bar"
          class="h-full bg-[#3F89FC] shadow-[0_0_15px_#3F89FC] w-0 transition-all duration-100 ease-out"
        />
      </div>
    )
  }

  <!-- Page Load Progress Bar -->
  <div
    id="page-load-progress-bar"
    class="fixed top-0 left-0 h-1 bg-white z-[100] transition-all duration-200 ease-out opacity-0 w-0 pointer-events-none shadow-[0_0_10px_rgba(255,255,255,0.5)]"
  >
  </div>
</header>

<script>
  // Page Load Progress Bar Logic
  const setupPageLoadProgress = () => {
    const progressBar = document.getElementById("page-load-progress-bar");
    if (!progressBar) return;

    // Reset progress bar state
    const resetProgress = () => {
      progressBar.style.width = "0%";
      progressBar.style.opacity = "0";
    };

    // Start progress animation
    const startProgress = () => {
      progressBar.style.transition =
        "width 0.2s ease-out, opacity 0.2s ease-out";
      progressBar.style.opacity = "1";
      progressBar.style.width = "20%"; // Initial jump

      // Simulate progress
      const simulate = () => {
        if (progressBar.style.width === "100%") return;
        const currentWidth = parseFloat(progressBar.style.width) || 0;
        if (currentWidth < 90) {
          const increment = Math.random() * 10 + 5;
          progressBar.style.width = `${Math.min(currentWidth + increment, 90)}%`;
          requestAnimationFrame(() => setTimeout(simulate, 200));
        }
      };
      setTimeout(simulate, 200);
    };

    // Complete progress animation
    const completeProgress = () => {
      progressBar.style.width = "100%";
      setTimeout(() => {
        progressBar.style.opacity = "0";
        setTimeout(() => {
          progressBar.style.width = "0%";
        }, 200); // Wait for fade out
      }, 300); // Wait for width transition
    };

    document.addEventListener("astro:before-preparation", startProgress);
    document.addEventListener("astro:after-preparation", () => {
      // Boost progress
      if (progressBar) {
        const currentWidth = parseFloat(progressBar.style.width) || 0;
        progressBar.style.width = `${Math.min(currentWidth + 20, 95)}%`;
      }
    });
    document.addEventListener("astro:page-load", completeProgress);

    // Immediate feedback on click
    document.addEventListener("click", (e) => {
      const target = (e.target as Element)?.closest("a");
      if (!target) return;

      const href = target.getAttribute("href");
      if (!href) return;

      // Check if it's an internal link and not a new tab/window
      if (
        href.startsWith("/") &&
        !href.startsWith("#") &&
        target.target !== "_blank" &&
        !e.ctrlKey &&
        !e.metaKey &&
        !e.shiftKey &&
        !e.altKey
      ) {
        startProgress();
      }
    });
  };

  // Run setup
  setupPageLoadProgress();

  const setupMobileMenu = () => {
    const btn = document.getElementById("mobile-menu-btn");
    const menu = document.getElementById("mobile-menu");
    const iconOpen = document.getElementById("menu-icon-open");
    const iconClose = document.getElementById("menu-icon-close");
    const mobileLinks = document.querySelectorAll(".mobile-link");

    if (btn && menu && iconOpen && iconClose) {
      let isOpen = false;

      const toggleMenu = (forceClose = false) => {
        const shouldClose = forceClose || isOpen;
        const header = document.querySelector("header");

        if (shouldClose) {
          // Close
          menu.classList.add(
            "translate-y-[-100%]",
            "opacity-0",
            "pointer-events-none",
          );
          menu.classList.remove(
            "translate-y-0",
            "opacity-100",
            "pointer-events-auto",
          );

          // Icon state
          iconOpen.classList.remove("opacity-0", "rotate-90", "scale-50");
          iconOpen.classList.add("opacity-100", "rotate-0", "scale-100");

          iconClose.classList.remove("opacity-100", "rotate-0", "scale-100");
          iconClose.classList.add("opacity-0", "-rotate-90", "scale-50");

          // Header background state
          header?.classList.remove("bg-[#111]", "backdrop-blur-none");
          header?.classList.add("bg-[#111]/80", "backdrop-blur-md");

          document.body.style.overflow = "";
          isOpen = false;
        } else {
          // Open
          menu.classList.remove(
            "translate-y-[-100%]",
            "opacity-0",
            "pointer-events-none",
          );
          menu.classList.add(
            "translate-y-0",
            "opacity-100",
            "pointer-events-auto",
          );

          // Icon state
          iconOpen.classList.remove("opacity-100", "rotate-0", "scale-100");
          iconOpen.classList.add("opacity-0", "rotate-90", "scale-50");

          iconClose.classList.remove("opacity-0", "-rotate-90", "scale-50");
          iconClose.classList.add("opacity-100", "rotate-0", "scale-100");

          // Header background state
          header?.classList.remove("bg-[#111]/80", "backdrop-blur-md");
          header?.classList.add("bg-[#111]", "backdrop-blur-none");

          document.body.style.overflow = "hidden";
          isOpen = true;
        }
      };

      btn.onclick = (e) => {
        e.stopPropagation();
        toggleMenu();
      };

      // Close menu when clicking links
      mobileLinks.forEach((link) => {
        link.addEventListener("click", () => toggleMenu(true));
      });

      // Reset state on resize
      const handleResize = () => {
        if (window.innerWidth >= 768 && isOpen) {
          toggleMenu(true);
        }
      };
      window.addEventListener("resize", handleResize);
    }
  };

  const setupReadingProgress = () => {
    const progressBar = document.getElementById("reading-progress-bar");
    if (!progressBar) return;

    const updateProgress = () => {
      const articleContainer = document.getElementById(
        "article-main-container",
      );

      let scrolled = 0;

      if (articleContainer) {
        // Calculate based on specific container
        const containerRect = articleContainer.getBoundingClientRect();
        const containerHeight = containerRect.height;
        const containerTop = containerRect.top + window.scrollY;
        const windowHeight = window.innerHeight;

        // Start counting when the top of the container is at the top of the viewport (or slightly adjusted for header)
        // End counting when the bottom of the container hits the bottom of the viewport

        const start = containerTop;
        const end = containerTop + containerHeight - windowHeight;

        if (window.scrollY < start) {
          scrolled = 0;
        } else if (window.scrollY > end) {
          scrolled = 100;
        } else {
          scrolled = ((window.scrollY - start) / (end - start)) * 100;
        }
      } else {
        // Fallback to full page if no specific container found (though enableReadingProgress should imply it exists or we want page wide)
        // For consistency with user request "only calculate valid in article page", we might want to default to 0 if not found,
        // but let's keep page fallback for robustness or other pages if enabled.
        const scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop;
        const scrollHeight =
          document.documentElement.scrollHeight || document.body.scrollHeight;
        const clientHeight =
          document.documentElement.clientHeight || document.body.clientHeight;
        scrolled = (scrollTop / (scrollHeight - clientHeight)) * 100;
      }

      progressBar.style.width = `${scrolled}%`;
    };

    window.addEventListener("scroll", updateProgress);
    window.addEventListener("resize", updateProgress); // Recalculate on resize
    updateProgress(); // Initial call

    document.addEventListener(
      "astro:before-swap",
      () => {
        window.removeEventListener("scroll", updateProgress);
        window.removeEventListener("resize", updateProgress);
      },
      { once: true },
    );
  };

  document.addEventListener("astro:page-load", setupMobileMenu);
  document.addEventListener("astro:page-load", setupReadingProgress);

  // Also run on initial load if astro:page-load doesn't fire immediately (fallback)
  if (document.readyState === "complete") {
    setupMobileMenu();
    setupReadingProgress();
  } else {
    document.addEventListener("DOMContentLoaded", () => {
      setupMobileMenu();
      setupReadingProgress();
    });
  }
</script>
